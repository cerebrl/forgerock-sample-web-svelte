import { SvelteComponent, init, safe_not_equal, element, text, attr, insert, append, set_data, detach, space, create_component, mount_component, listen, transition_in, transition_out, destroy_component, run_all, component_subscribe } from 'svelte/internal';
import Eye_icon from '../../icons/eye-icon.svelte.js';
import { theme } from '../../../global-state.js';

/* src/lib/components/journey/callbacks/create-password.svelte generated by Svelte v3.47.0 */

function create_if_block(ctx) {
	let div;
	let t;

	return {
		c() {
			div = element("div");
			t = text(/*validationFailure*/ ctx[4]);
			attr(div, "class", "invalid-feedback");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*validationFailure*/ 16) set_data(t, /*validationFailure*/ ctx[4]);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let input;
	let input_class_value;
	let input_type_value;
	let t0;
	let label;
	let t1;
	let t2;
	let button;
	let eyeicon;
	let button_class_value;
	let t3;
	let current;
	let mounted;
	let dispose;
	eyeicon = new Eye_icon({ props: { visible: /*isVisible*/ ctx[2] } });
	let if_block = /*validationFailure*/ ctx[4] && create_if_block(ctx);

	return {
		c() {
			div = element("div");
			input = element("input");
			t0 = space();
			label = element("label");
			t1 = text(/*passwordLabel*/ ctx[6]);
			t2 = space();
			button = element("button");
			create_component(eyeicon.$$.fragment);
			t3 = space();
			if (if_block) if_block.c();

			attr(input, "class", input_class_value = `cstm_input-password form-control ${/*validationClass*/ ctx[3]
			? /*validationClass*/ ctx[3]
			: ''} border-end-0 bg-transparent ${/*$theme*/ ctx[5].textClass} ${/*$theme*/ ctx[5].borderClass}`);

			attr(input, "id", /*inputName*/ ctx[0]);
			attr(input, "name", /*inputName*/ ctx[0]);
			attr(input, "placeholder", /*passwordLabel*/ ctx[6]);
			attr(input, "type", input_type_value = /*isVisible*/ ctx[2] ? 'text' : 'password');
			input.required = /*isRequired*/ ctx[1];
			attr(label, "for", /*inputName*/ ctx[0]);
			attr(button, "class", button_class_value = `cstm_input-icon border-start-0 input-group-text bg-transparent ${/*$theme*/ ctx[5].textClass} ${/*$theme*/ ctx[5].borderClass}`);
			attr(button, "type", "button");
			attr(div, "class", "cstm_form-floating input-group form-floating mb-3");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			append(div, t0);
			append(div, label);
			append(label, t1);
			append(div, t2);
			append(div, button);
			mount_component(eyeicon, button, null);
			append(div, t3);
			if (if_block) if_block.m(div, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(input, "change", /*setValue*/ ctx[7]),
					listen(button, "click", /*toggleVisibility*/ ctx[8])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*validationClass, $theme*/ 40 && input_class_value !== (input_class_value = `cstm_input-password form-control ${/*validationClass*/ ctx[3]
			? /*validationClass*/ ctx[3]
			: ''} border-end-0 bg-transparent ${/*$theme*/ ctx[5].textClass} ${/*$theme*/ ctx[5].borderClass}`)) {
				attr(input, "class", input_class_value);
			}

			if (!current || dirty & /*inputName*/ 1) {
				attr(input, "id", /*inputName*/ ctx[0]);
			}

			if (!current || dirty & /*inputName*/ 1) {
				attr(input, "name", /*inputName*/ ctx[0]);
			}

			if (!current || dirty & /*isVisible*/ 4 && input_type_value !== (input_type_value = /*isVisible*/ ctx[2] ? 'text' : 'password')) {
				attr(input, "type", input_type_value);
			}

			if (!current || dirty & /*isRequired*/ 2) {
				input.required = /*isRequired*/ ctx[1];
			}

			if (!current || dirty & /*inputName*/ 1) {
				attr(label, "for", /*inputName*/ ctx[0]);
			}

			const eyeicon_changes = {};
			if (dirty & /*isVisible*/ 4) eyeicon_changes.visible = /*isVisible*/ ctx[2];
			eyeicon.$set(eyeicon_changes);

			if (!current || dirty & /*$theme*/ 32 && button_class_value !== (button_class_value = `cstm_input-icon border-start-0 input-group-text bg-transparent ${/*$theme*/ ctx[5].textClass} ${/*$theme*/ ctx[5].borderClass}`)) {
				attr(button, "class", button_class_value);
			}

			if (/*validationFailure*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(eyeicon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(eyeicon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(eyeicon);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $theme;
	component_subscribe($$self, theme, $$value => $$invalidate(5, $theme = $$value));
	let { callback } = $$props;
	let { inputName = '' } = $$props;
	const failedPolicies = callback.getFailedPolicies && callback.getFailedPolicies();
	const policies = callback.getPolicies && callback.getPolicies();
	const passwordLabel = callback.getPrompt();
	let isRequired = false;
	let isVisible = false;
	let validationClass = '';
	let validationFailure;

	/**
 * @function setValue - Sets the value on the callback on element blur (lose focus)
 * @param {Object} event
 */
	function setValue(event) {
		callback.setPassword(event.target.value);
	}

	/**
 * @function toggleVisibility - toggles the password from masked to plaintext
 */
	function toggleVisibility() {
		$$invalidate(2, isVisible = !isVisible);
	}

	if (failedPolicies?.length) {
		/**
 * Iterate over the failed policies producing a single string to render
 */
		validationFailure = failedPolicies.reduce(
			(prev, curr) => {
				console.log(curr);
				let failureObj;

				try {
					failureObj = JSON.parse(curr.policyRequirement);
				} catch(err) {
					console.log(`Parsing failure for ${passwordLabel}`);
				}

				switch (failureObj.policyRequirement) {
					case 'LENGTH_BASED':
						prev = `${prev}Ensure password contains more than ${failureObj.params['min-password-length']} characters. `;
						break;
					case 'CHARACTER_SET':
						prev = `${prev}Ensure password contains 1 of each: capital letter, number and special character. `;
						break;
					default:
						prev = `${prev}Please check this value for correctness.`;
				}

				return prev;
			},
			''
		);

		validationClass = 'is-invalid';
	}

	/**
 * Determine if the input is required
 */
	if (policies?.policyRequirements) {
		isRequired = policies.policyRequirements.includes('REQUIRED');
	} else if (callback.isRequired) {
		isRequired = callback.isRequired();
	}

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(9, callback = $$props.callback);
		if ('inputName' in $$props) $$invalidate(0, inputName = $$props.inputName);
	};

	return [
		inputName,
		isRequired,
		isVisible,
		validationClass,
		validationFailure,
		$theme,
		passwordLabel,
		setValue,
		toggleVisibility,
		callback
	];
}

class Create_password extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { callback: 9, inputName: 0 });
	}
}

export { Create_password as default };
