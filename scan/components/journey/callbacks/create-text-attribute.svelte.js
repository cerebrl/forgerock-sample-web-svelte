import { SvelteComponent, init, safe_not_equal, element, text, attr, insert, append, set_data, detach, space, listen, noop, component_subscribe } from 'svelte/internal';
import { theme } from '../../../global-state.js';

/* src/lib/components/journey/callbacks/create-text-attribute.svelte generated by Svelte v3.47.0 */

function create_if_block(ctx) {
	let div;
	let t;

	return {
		c() {
			div = element("div");
			t = text(/*validationFailure*/ ctx[3]);
			attr(div, "class", "invalid-feedback");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*validationFailure*/ 8) set_data(t, /*validationFailure*/ ctx[3]);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let input;
	let input_class_value;
	let t0;
	let label;
	let t1;
	let t2;
	let mounted;
	let dispose;
	let if_block = /*validationFailure*/ ctx[3] && create_if_block(ctx);

	return {
		c() {
			div = element("div");
			input = element("input");
			t0 = space();
			label = element("label");
			t1 = text(/*textInputLabel*/ ctx[6]);
			t2 = space();
			if (if_block) if_block.c();
			attr(input, "class", input_class_value = `cstm_form-control form-control ${/*validationClass*/ ctx[2]} bg-transparent ${/*$theme*/ ctx[4].textClass} ${/*$theme*/ ctx[4].borderClass}`);
			input.value = /*existingValue*/ ctx[5];
			attr(input, "id", /*inputName*/ ctx[0]);
			attr(input, "name", /*inputName*/ ctx[0]);
			attr(input, "placeholder", /*textInputLabel*/ ctx[6]);
			input.required = /*isRequired*/ ctx[1];

			attr(input, "type", /*stringAttributeName*/ ctx[7] == 'mail'
			? 'email'
			: 'text');

			attr(label, "for", /*inputName*/ ctx[0]);
			attr(div, "class", `cstm_form-floating form-floating mb-3`);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			append(div, t0);
			append(div, label);
			append(label, t1);
			append(div, t2);
			if (if_block) if_block.m(div, null);

			if (!mounted) {
				dispose = listen(input, "change", /*setValue*/ ctx[8]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*validationClass, $theme*/ 20 && input_class_value !== (input_class_value = `cstm_form-control form-control ${/*validationClass*/ ctx[2]} bg-transparent ${/*$theme*/ ctx[4].textClass} ${/*$theme*/ ctx[4].borderClass}`)) {
				attr(input, "class", input_class_value);
			}

			if (dirty & /*inputName*/ 1) {
				attr(input, "id", /*inputName*/ ctx[0]);
			}

			if (dirty & /*inputName*/ 1) {
				attr(input, "name", /*inputName*/ ctx[0]);
			}

			if (dirty & /*isRequired*/ 2) {
				input.required = /*isRequired*/ ctx[1];
			}

			if (dirty & /*inputName*/ 1) {
				attr(label, "for", /*inputName*/ ctx[0]);
			}

			if (/*validationFailure*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $theme;
	component_subscribe($$self, theme, $$value => $$invalidate(4, $theme = $$value));
	let { callback } = $$props;
	let { inputName = '' } = $$props;
	const existingValue = callback.getInputValue();
	const failedPolicies = callback.getFailedPolicies && callback.getFailedPolicies();
	const policies = callback.getPolicies && callback.getPolicies();
	const textInputLabel = callback.getPrompt();
	let isRequired = false;
	let stringAttributeName = callback.getName && callback.getName();
	let validationClass = '';
	let validationFailure;

	/**
 * @function setValue - Sets the value on the callback on element blur (lose focus)
 * @param {Object} event
 */
	function setValue(event) {
		callback.setInputValue(event.target.value);
	}

	if (failedPolicies?.length) {
		/**
 * Iterate over the failed policies producing a single string to render
 */
		validationFailure = failedPolicies.reduce(
			(prev, curr) => {
				let failureObj;

				try {
					failureObj = JSON.parse(curr.policyRequirement);
				} catch(err) {
					console.log(`Parsing failure for ${textInputLabel}`);
				}

				switch (failureObj.policyRequirement) {
					case 'VALID_USERNAME':
						prev = `${prev}Please choose a different username. `;
						break;
					case 'VALID_EMAIL_ADDRESS_FORMAT':
						prev = `${prev}Please use a valid email address. `;
						break;
					default:
						prev = `${prev}Please check this value for correctness.`;
				}

				return prev;
			},
			''
		);

		validationClass = 'is-invalid';

		/**
 * Determine if the input is required
 */
		if (policies?.policyRequirements) {
			isRequired = policies.policyRequirements.includes('REQUIRED');
		} else if (callback.isRequired) {
			isRequired = callback.isRequired();
		}
	}

	$$self.$$set = $$props => {
		if ('callback' in $$props) $$invalidate(9, callback = $$props.callback);
		if ('inputName' in $$props) $$invalidate(0, inputName = $$props.inputName);
	};

	return [
		inputName,
		isRequired,
		validationClass,
		validationFailure,
		$theme,
		existingValue,
		textInputLabel,
		stringAttributeName,
		setValue,
		callback
	];
}

class Create_text_attribute extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { callback: 9, inputName: 0 });
	}
}

export { Create_text_attribute as default };
